# Javascript | 연산자

## 연산자란

연산자는 하나 이상의 **표현식**을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행하여 하나의 **값**을 만든다.  
연산의 대상을 피연산자라 하고 피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 그리고 연산자와 피연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 **표현식**이다.

<br>
<br>

## 1. 산술 연산자

산술 연산자는 수학적 계산을 수행하여 새로운 **숫자 값**을 만든다.<br>
산술 연산이 불가능한 경우 `NaN` 을 반환한다.

산술 연산자는 피연산자의 개수에 따라 이항 산술연산자, 단항 산술 연산자로 구분 할 수 있다.

<br>

### 1-1. 이항 산술 연산자

2개의 피연산자를 계산하여 숫자 값을 만든다.  
이항 산술 연산자는 피연산자의 값을 변경하는 부수효과가 없으며 계산의 새로운 **값**을 만들 뿐이다.

```jsx
/* EX */
1 + 1; // 2
1 - 1; // 0
2 * 2; // 4
4 / 2; // 2
5 % 2; // 1
```

> 부수효과란? <br>
> 피연산자 값이 변하는 경우를 부수효과라고 한다.

<br>

### 1-2. 단항 산술 연산자

1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
이항 산술 연산자와 달리 **증가/감소**가 있기 때문에 피연산의 값을 변경하는 할당이 이뤄진다.

```jsx
var a = 1;

teat++;
console.log(a); // 2

a--;
console.log(a); // 1
```

<br>

**증가/감소 연산자는 위치에 의미가 있다.**

- 피연산자 앞에 위치 한다면 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산을 수행
- 피연산 뒤에 위치 한다면 먼저 다른 연산을 수행 한 후 피연산자의 값을 증가/감소 시킨다.

<br>

#### **+ 단항 연산자**

숫자 타입이 아닌 피연산자에 `+` 단항 연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환한다. 주의할 점은 피연산자를 변경하는 것이 아닌 숫자 타입으로 **변환한 값을 생성해서 반환**한다.  
따로 부수효과는 존재하지 않는다.

```jsx
var a = "1";

// 문자열은 숫자로 타입 변환
console.log(+a); // 1
// 부수 효과 없음
console.log(a); // "1"

// Boolean 값을 숫자로 타입 변환
var b = true;
var c = false;
console.log(+b, +c); // 1, 0
// 부수 효과 없음
console.log(b, c); // true, false

// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환
var d = "hello world!";
console.log(+d); // NaN
// 부수 효과 없음
console.log(d); // "hello world!"
```

<br>

#### **- 단항 연산자**

`-` 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. `+` 단항 연산자와 같이 숫자 타입이 아닌 피연산자에 사용 할 시 숫자타입으로 변환하여 반환한다.  
이때, 피연산자의 부수효과는 없지만 부호를 반전한 값을 생성하여 반환한다.

```jsx
// 부호를 반전
-(-10); // 10

// 문자열을 숫자로 타입 변환
-"10"; // -10

// Boolean 값을 숫자로 타입 변환
-true; // -1

// 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환
-"hello world!"; // NaN
```

<br>

### 1-3. 문자열 연결 연산자

피연사자 중 하나 이상이 문자열인 경우 `+` 연산자가 문자열 연결 연산자로 동작한다. 그 외의 경우는 산술 연산자로 동작한다.

```jsx
// 문자열 연결 연산자
"1" + 2; // -> '12'
1 + "2"; // -> '12'

// 산술 연산자
1 + 2; // -> 3

// true는 1로 타입 변환
1 + true; // -> 2

// false는 0으로 타입 변환
1 + false; // -> 1

// null은 0으로 타입 변환
1 + null; // -> 1

// undefined는 숫자로 타입 변환되지 않음
+undefined; // -> NaN
1 + undefined; // -> NaN
```

위 코드에서 본것처럼 자바스크립트 엔진에 의하여 암묵적으로 타입이 자동 변환되기도 한다는 것이다. 이를 **암묵적 타입 변환 또는, 타입 강제 변환**이라고 한다.

<br>
<br>

## 2. 할당 연산자

우항에 있는 피연산자의 결과를 좌항의 변수에 할당한다.  
할당 연산자는 변수에 값을 할당하기 때문에 부수효과가 존재한다.

<br>

```jsx
var a;

a = 10;
console.log(a); // 10

a += 5; // a = a + 5
console.log(a); // 15

a -= 5; // a = a - 5
console.log(a); // 10

a *= 5; // a = a * 5
console.log(a); // 50

a /= 5; // a = a / 5
console.log(a); // 10

a %= 5; // a = a % 5
console.log(a); // 0

var str = "I'm a ";

// 문자열 연결 연산자
str += "String!";
console.log(str); // "I'm a String!"
```

<br>

중요한 부분은 할당문은 **값으로 평가되는 표현식인 문으로 할당된 값으로 평가된다.** 이러한 특징을 활용하여 여러 변수에 동일한 값을 할당할 수 있다.

```jsx
var a, b, c;

// 연쇄 할당 : 오른쪽에서 왼쪽으로 진행

a = b = c = 0;

console.log(a, b, c); // 0 0 0
```

<br>
<br>

## 3. 비교 연산자

비교 연산자는 좌/우항의 피연산자를 비교 이후 결과를 `Boolean` 값으로 반환한다.  
비교 연산자는 `if` 문이나 `for` 문에서 자주 사용된다.

<br>

### 3-1. 동등/일치 비교 연산자

동등/일치 비교 연산자는 좌/우항의 피연산자의 값을 비교 하여 `Boolean` 값을 반환한다. 하지만 비교하는 엄격성이 정도가 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.

| 비교 연산자 |    의미     |  사례   |           설명           | 부수효과 |
| :---------: | :---------: | :-----: | :----------------------: | :------: |
|     ==      |  동등 비교  | x == y  |    x와 y의 값이 같음     |    X     |
|     ===     |  일치 비교  | x === y | x와 y의 값과 타입이 같음 |    X     |
|     !=      | 부동등 비교 | x != y  |    x와 y의 값이 다름     |    X     |
|     !==     | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 |    X     |

<br>

문자열 연결 연산자에서 보았듯 자바스크립트 엔진에 의하여 암묵적으로 타입이 자동 변환 될 때 **동등 비교 연산자(`==`)은 좌/우항을 먼저 암묵적으로 타입을 일치시킨 후 같은 값인지 비교한다.** 결과적으로 동등 비교 연산자는 좌/우항의 타입이 다르더라도 **암묵적**으로 타입을 변환 한 후에 같은 값이라면 `true`를 반환한다.

<br>

```jsx
// 동등 비교
1 == 1; // true

// 타입은 다르지만 암묵적 타입 변환을 통하여 일치한 경우
1 == "1"; // true
```

이처럼 동등 비교 연산자는 편리하기도 하지만 **결과를 예측**하기 어렵고 **실수** 할 확률이 높다.<br>
따라서 동등 비교 연산자는 사용을 자제하고 **일치 비교 연산자(`===`)** 를 활용하여 비교를 하는 것을 권장한다.

일치 비교 연산자는 **좌/우항의 타입도 같고 값도 같은 경우에 한하여 `true`를 반환한다.** 동등 비교 연산자와는 달리 암묵적인 타입 변환을 하지 않기 때문에 예측하기 쉽고 실수할 확률도 줄일 수 있다.

```jsx
// 일치 비교

// 값과 타입이 같은 경우
1 === 1; // true

// 표기상 값은 같지만 타입이 다른 경우
1 === "1"; // false
```

<br>

일치 비교 연산자에서 주의할 점은 `NaN` 인데 `NaN`은 자신과 일치하지 않는 유일한 값이다. 숫자가 `NaN`인지 확인하고 싶다면 `isNaN` 함수를 사용하여 확인할 수 있다.

```jsx
// isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 Boolean 값으로 반환한다.

isNaN(NaN); // true
isNaN(10); // false
isNaN(1 + undefined); // true
```

또 하나 주의 할 점은 양의 0(+0)과 음의 0(-0)이 있는데 이 둘을 비교하면 `true`를 반환한다.

> 정리하자면 각 비교 연산자(!=과 == 같이)는 서로 반대의 개념을 지니고 있다.

<br>

### 3-2. 대소 관계 비교 연산자

피연산자의 크기를 비교하여 `Boolean` 값을 반환한다.

| 대소 관계 비교 연산자 |  예제  |         설명          | 부수효과 |
| :-------------------: | :----: | :-------------------: | :------: |
|           >           | x > y  |    x가 y보다 크다     |    X     |
|           <           | x < y  |    x가 y보다 작다     |    X     |
|          >=           | x >= y | x가 y보다 크거나 같다 |    X     |
|          <+           | x <= y | x가 y보다 작거나 같다 |    X     |

<br>

```jsx
// 대소 관계 비교
5 > 0; // true
5 > 5; // false
5 >= 5; // true
5 <= 5; // true
```
